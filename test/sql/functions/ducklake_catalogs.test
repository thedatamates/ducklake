# name: test/sql/functions/ducklake_catalogs.test
# description: test ducklake_catalogs function
# group: [functions]

require ducklake

require parquet

statement ok
ATTACH 'ducklake:__TEST_DIR__/catalogs_meta.db' AS ducklake (DATA_PATH '__TEST_DIR__/catalogs_data', CATALOG 'main_catalog', CREATE_IF_NOT_EXISTS true);

# Initial state - should have one catalog
query I
SELECT COUNT(*) FROM ducklake_catalogs('ducklake');
----
1

query IT
SELECT catalog_id, catalog_name FROM ducklake_catalogs('ducklake') ORDER BY catalog_id;
----
0	main_catalog

# Fork to create second catalog
statement ok
SELECT * FROM ducklake_fork_catalog('ducklake', 'forked_catalog');

# Now should have two catalogs
query I
SELECT COUNT(*) FROM ducklake_catalogs('ducklake');
----
2

# Verify both catalogs exist (using name ordering to avoid ID assumptions)
query T
SELECT catalog_name FROM ducklake_catalogs('ducklake') ORDER BY catalog_name;
----
forked_catalog
main_catalog

# Verify UUID column exists and is not null
query I
SELECT COUNT(*) FROM ducklake_catalogs('ducklake') WHERE catalog_uuid IS NOT NULL;
----
2

# Verify parent_catalog_id: root has NULL, fork has parent's ID
query TI
SELECT catalog_name, CASE WHEN parent_catalog_id IS NULL THEN 1 ELSE 0 END as is_root
FROM ducklake_catalogs('ducklake')
ORDER BY catalog_name;
----
forked_catalog	0
main_catalog	1

# Verify begin_snapshot and end_snapshot columns - all should be active
query I
SELECT CASE WHEN end_snapshot IS NULL THEN 1 ELSE 0 END as is_active
FROM ducklake_catalogs('ducklake')
ORDER BY catalog_name;
----
1
1

# Fork again to create third catalog
statement ok
SELECT * FROM ducklake_fork_catalog('ducklake', 'another_fork');

# Verify all three catalogs exist
query I
SELECT COUNT(*) FROM ducklake_catalogs('ducklake');
----
3

query T
SELECT catalog_name FROM ducklake_catalogs('ducklake') ORDER BY catalog_name;
----
another_fork
forked_catalog
main_catalog

statement ok
USE memory;

statement ok
DETACH ducklake;
