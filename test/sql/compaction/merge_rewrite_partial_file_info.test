# name: test/sql/compaction/merge_rewrite_partial_file_info.test
# description: Reproduce issue ##551 with REWRITE_DELETES and partial file info
# group: [compaction]

require ducklake

require parquet

test-env DUCKLAKE_CONNECTION __TEST_DIR__/{UUID}.db

test-env DATA_PATH __TEST_DIR__


statement ok
ATTACH 'ducklake:${DUCKLAKE_CONNECTION}' AS ducklake (DATA_PATH '${DATA_PATH}/reproduce_issue/', CATALOG 'test', CREATE_IF_NOT_EXISTS true);

statement ok
USE ducklake;

# Set small target file size to control merging behavior
statement ok
CALL ducklake_set_option('ducklake', 'target_file_size', '10KB');

statement ok
CREATE TABLE t (id INTEGER, data VARCHAR);

# Create a LARGE file A that won't be merged (exceeds target_file_size)
statement ok
INSERT INTO t SELECT i, repeat('x', 100) FROM range(5000) t(i);

# Create small files B and C that WILL be merged
statement ok
INSERT INTO t SELECT i + 5000, 'small1' FROM range(100) t(i);

statement ok
INSERT INTO t SELECT i + 5100, 'small2' FROM range(100) t(i);

# At this point we have 3 files
query I
SELECT COUNT(*) FROM ducklake_list_files('ducklake', 't');
----
3

# Merge B+C into a single file (A is too big to merge)
statement ok
CALL ducklake_merge_adjacent_files('ducklake', 't');

# State now:
# - File A (ids 0-4999): NO partial_file_info, begin_snapshot=3
# - Merged BC (ids 5000-5199): HAS partial_file_info, begin_snapshot=4
query I
SELECT COUNT(*) FROM ducklake_list_files('ducklake', 't') WHERE delete_file IS NULL;
----
2

# Only merged BC has partial_file_info
query I
SELECT partial_file_info FROM __ducklake_metadata_ducklake.ducklake_data_file WHERE end_snapshot IS NULL;
----
NULL
4:100|5:200

statement ok
INSERT INTO t SELECT i + 5200, 'small3' FROM range(10) t(i);

statement ok
INSERT INTO t SELECT i + 5210, 'small4' FROM range(10) t(i);

# Set small target file size so only D & E get merged
statement ok
CALL ducklake_set_option('ducklake', 'target_file_size', '1KB');

# Merge D+E into a single file (A is too big to merge)
statement ok
CALL ducklake_merge_adjacent_files('ducklake', 't');

# State now:
# - File A (ids 0-4999): NO partial_file_info, begin_snapshot=3
# - Merged BC (ids 5000-5199): HAS partial_file_info, begin_snapshot=4
# - Merged DE (ids 5200-5219): HAS partial_file_info, begin_snapshot=5
query I
SELECT COUNT(*) FROM ducklake_list_files('ducklake', 't') WHERE delete_file IS NULL;
----
3

query I
SELECT partial_file_info FROM __ducklake_metadata_ducklake.ducklake_data_file WHERE end_snapshot IS NULL;
----
NULL
4:100|5:200
7:10|8:20

# Delete from file A (no partial_file_info)
statement ok
DELETE FROM t WHERE id < 4900;

# Delete from merged file BC (has partial_file_info)
statement ok
DELETE FROM t WHERE id >= 5000 AND id < 5150;

# Set large target to merge all files
statement ok
CALL ducklake_set_option('ducklake', 'target_file_size', '1MB');

# Rewrite all data files, including ones with partial_file_info
statement ok
CALL ducklake_rewrite_data_files('ducklake', 't', delete_threshold => 0);

# Merge all of them into a single file
statement ok
CALL ducklake_merge_adjacent_files('ducklake', 't');

# Verify that we ended up with a single file
query I
SELECT COUNT(*) FROM ducklake_list_files('ducklake', 't');
----
1

# Ensure the time-travel works
query II
SELECT * FROM (
  SELECT '01_count_after_init' as version, COUNT(*) FROM t AT (VERSION => 2)
  UNION SELECT '02_count_after_A' as version, COUNT(*) FROM t AT (VERSION => 3)
  UNION SELECT '03_count_after_B' as version, COUNT(*) FROM t AT (VERSION => 4)
  UNION SELECT '04_count_after_C' as version, COUNT(*) FROM t AT (VERSION => 5)
  UNION SELECT '05_count_after_BC' as version, COUNT(*) FROM t AT (VERSION => 6)
  UNION SELECT '06_count_after_D' as version, COUNT(*) FROM t AT (VERSION => 7)
  UNION SELECT '07_count_after_E' as version, COUNT(*) FROM t AT (VERSION => 8)
  UNION SELECT '08_count_after_DE' as version, COUNT(*) FROM t AT (VERSION => 9)
  UNION SELECT '09_count_after_delete_from_A' as version, COUNT(*) FROM t AT (VERSION => 10)
  UNION SELECT '10_count_after_delete_from_BC' as version, COUNT(*) FROM t AT (VERSION => 11)
  UNION SELECT '11_count_after_rewrite' as version, COUNT(*) FROM t AT (VERSION => 12)
  UNION SELECT '12_final' as version, COUNT(*) FROM t
) ORDER BY version ASC;
----
01_count_after_init	0
02_count_after_A	5000
03_count_after_B	5100
04_count_after_C	5200
05_count_after_BC	5200
06_count_after_D	5210
07_count_after_E	5220
08_count_after_DE	5220
09_count_after_delete_from_A	320
10_count_after_delete_from_BC	170
11_count_after_rewrite	170
12_final	170
